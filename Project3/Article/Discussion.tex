\section{Discussion}
\subsection{The Different Algorithms}
When designing a program, or software for that matter, choosing your main, hard-coded algorithms wisely will dramatically improve the efficiency of said program and precision of the result you wish to produce. In our case, we have studied three different numerical schemes for solving a second order differential equation by recursion; the Euler - Forward and Euler - Cromer algorithms, as well as the Velocity Verlet algorithm. As we saw in Tables \ref{runtime}, \ref{error} and \ref{error_constN}, there are clear advantages to choosing the Velocity Verlet algorithm over the Euler methods. This is in part due to the global truncation error it commits, which decreases twice as fast as the error committed by the Euler methods. What concerns efficiency, we see that the tabulated CPU timings are insignificantly different, merely resulting from the difference in associated FLOPs being 5$N$ and 9$N$ respectively for the Euler methods and the Velocity Verlet method. In light of this, we here conclude that there is little reason taking this aspect into consideration when choosing between the three, especially when the slight halting is compensated by a much more precise algorithm. It should be made clear, however, that the data procured about the efficiency and precision of each algorithm has no statistical gravitas. The elapsed run times and maximum errors have undergone at most two trial runs each, leaving no room for possible deviations and more precise mean values. Looking at the anomalous increase in maximum numerical error for the Euler - Cromer algorithm in this respect, it is difficult to make conclusive arguments as to why the anomaly occurs. One may argue that the sudden increase in the maximum error is due to numerical round off as this is the case for many algorithms when employing very high temporal resolutions, yet one should expect that this would be the case for the Euler - Forward algorithm, too, if not for all three algorithms. 
\subsection{Conservation of Angular Momentum}
As described in Section \ref{tests}, the function \texttt{TEST\_kepler()} tests - by Kepler's second law - for each run whether the angular momentum was conserved or not. Table \ref{conservationtable} shows that up until 100 years, the step sizes needed are roughly the same. For 1000 years, a step size twice as small is needed. It is however unreasonable to expect this simulation to give correct values for more than a few centuries, so the step size needed for conservation of angular momentum can be taken to be in the order of $10^{-3}$. The tolerance given to the \texttt{TEST\_kepler()} function has been chosen through trial and error, but as we have found, any arbitrary value can be given, and conservation of angular momentum achieved with sufficiently small time steps.

\subsection{Testing Forms of the Force}
With an elliptical orbit, the Earth-Sun system quickly diverges from the real system for increasing values of $\beta$ in the force term. For $\beta = 3$, the Earth falls into the sun before having done one revolution around the Sun. An inspection of the total energy of the system shows clearly that $\beta > 2$ is not representative of a real physical system. The energy is conserved for $\beta = 2$, which is the normal inverse square gravitational force. With a circular orbit, we have shown data for $\beta = 2.01$, and already for this small increase of the exponent, the total energy fluctuates. This is also reflected by Kepler's second law, as the angular momentum is not conserved for the systems as $\beta$ is increased beyond $2$. 

\subsection{Escape Velocity}
In the Theory-section, an analytical value for the escape velocity of Earth was found to be $\sqrt{8}\pi$. If we from trial and error use the initial velocity where the total energy is zero according to the results obtained in Figure \ref{EscVel_trial}, we see that the numerical value is 8.89 which corresponds closely to the analytical value from the Theory-section:  $\sqrt{8}\pi \sim 8.89$.

\subsection{The Three-Body System}
Figures \ref{jupiter12and120} and \ref{jupiter1200and12000} shows that the Velocity Verlet solver we have made is stable on the order of centuries for the three-body problem. After one millennium, it's clear that Earth's orbit is no longer stable, and after 12 millenniums, Jupiter's orbit itself is also unstable. Considering the respective temporal resolutions $h = 1.2\cdot10^{-5}, 1.2\cdot10^{-4}, 1.2\cdot10^{-3}$ and $1.2\cdot10^{-2}$, we see that the Velocity Verlet integrator produces well behaved solutions for high temporal resolutions, and for low temporal resolutions the solutions become highly unstable - similar to the behaviour of the Earth in the Earth-Sun system. This leads us to appreciate our program as flexible with the ability of adding bodies systemically without risking the expense of greater numerical errors. 

\subsection{The N-Body System}
Finally, as one may see in Figure \ref{nbody}, we have reached the final desired result - a fully functioning model for our Solar System. The plot includes the orbits of all planets in our Solar System, including Pluto, too. In the .cpp - file \texttt{multibodysystem.cpp} we have included NASA data for our moon, Luna, as well as three of the largest moons of Jupiter (Io, Europa and Ganymede) - we have decided not to include plots of these celestial bodies, however, as they orbit so close to Jupiter that it is difficult to view the orbit of Jupiter and its moons simultaneously. Some tedious zooming have however led us to conclude that these orbits too are physically feasible. As was previously mentioned, all simulations, including the simulations of all eight planets and Pluto, are run for systems in which the sun is fixed. The reason for this in the case of the N-body system, is that our group mistook the NASA data as being given in an inertial frame. A little too late we came to the realization that this was not the case, and that we indeed should have corrected our system's inertial reference frame with a center of mass such that the system has no net angular momentum. We still see our results as indicative of a program capable of producing results for large systems, being one of the major goals in light of object orienting our code. The code is written such that object such as moons and satellites can easily be added. We've opted to not do this, but this could be done when expanding the model further. 

\subsection{Perihelion Precession of Mercury} 
A goal of this project was to have our model produce results which are measured experimentally, more specifically; the Newtonian model for gravitation predicts a perihelion precession for Mercury which is is off by 43 arc seconds from experimental data. We wished to see whether we could add a relativistic term to the gravitational force term and make up for this discrepancy between the Newtonian model and the real Solar system. The data in Table \ref{thetatableunfixed} gives values of the precession which obviously is wrong, as the perihelion precession for both force-models are off by one order of magnitude. Table \ref{thetatablefixed} gives data which are closer to what we wished to achieve, but is still inconclusive. We have been unable to uncover why our results do not reflect what we expect.